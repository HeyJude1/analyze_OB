// Driver for 00_blas_gemm for Serial, OpenMP, MPI, and MPI+OpenMP
// Matrix-Matrix Multiplication: C = alpha * A * B + beta * C
// Based on OpenBLAS dgemm_small_kernel_b0_nn implementation

#include <algorithm>
#include <cmath>
#include <numeric>
#include <random>
#include <vector>

#include "utilities.hpp"
#include "baseline.hpp"
#include "generated-code.hpp"   // code generated by LLM

struct Context {
    std::vector<double> A;
    std::vector<double> B; 
    std::vector<double> C;
    std::vector<double> C_ref;  // reference result
    BLASLONG M, N, K;
    BLASLONG lda, ldb, ldc;
    double alpha, beta;
};

void reset(Context *ctx) {
    // Fill matrices with random values
    fillRand(ctx->A, -1.0, 1.0);
    fillRand(ctx->B, -1.0, 1.0);
    fillRand(ctx->C, -1.0, 1.0);
    
    // Broadcast for MPI consistency
    BCAST(ctx->A, DOUBLE);
    BCAST(ctx->B, DOUBLE);
    BCAST(ctx->C, DOUBLE);
    
    // Copy C for reference computation
    ctx->C_ref = ctx->C;
}

Context *init() {
    Context *ctx = new Context();
    
    // Problem size (can be adjusted via DRIVER_PROBLEM_SIZE)
    ctx->M = DRIVER_PROBLEM_SIZE;
    ctx->N = DRIVER_PROBLEM_SIZE; 
    ctx->K = DRIVER_PROBLEM_SIZE;
    
    // Leading dimensions (row-major, so ld = number of columns)
    ctx->lda = ctx->K;
    ctx->ldb = ctx->N;
    ctx->ldc = ctx->N;
    
    // BLAS parameters
    ctx->alpha = 1.0;
    ctx->beta = 0.0;  // C = A * B (no accumulation)
    
    // Allocate matrices
    ctx->A.resize(ctx->M * ctx->K);
    ctx->B.resize(ctx->K * ctx->N);
    ctx->C.resize(ctx->M * ctx->N);
    ctx->C_ref.resize(ctx->M * ctx->N);
    
    reset(ctx);
    return ctx;
}

void NO_OPTIMIZE compute(Context *ctx) {
    // Call the LLM-generated function
    // Expected signature: gemm(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc)
    gemm(ctx->M, ctx->N, ctx->K, ctx->alpha, 
         ctx->A, ctx->lda, ctx->B, ctx->ldb, 
         ctx->beta, ctx->C, ctx->ldc);
}

void NO_OPTIMIZE best(Context *ctx) {
    // Call the reference implementation
    correctGemm(ctx->M, ctx->N, ctx->K, ctx->alpha,
                ctx->A, ctx->lda, ctx->B, ctx->ldb,
                ctx->beta, ctx->C_ref, ctx->ldc);
}

bool validate(Context *ctx) {
    const double tolerance = 1e-6;
    
    // Compute reference result
    std::vector<double> C_test = ctx->C;
    correctGemm(ctx->M, ctx->N, ctx->K, ctx->alpha,
                ctx->A, ctx->lda, ctx->B, ctx->ldb,
                ctx->beta, C_test, ctx->ldc);
    
    // Compare with generated result
    bool isValid = blas_utils::compareMatrices(ctx->C, C_test, 
                                               ctx->M, ctx->N, tolerance);
    
    if (!isValid) {
        double error = blas_utils::relativeError(ctx->C, C_test);
        printf("GEMM validation failed: relative error = %e\n", error);
    }
    
    return isValid;
}

void destroy(Context *ctx) {
    delete ctx;
}
