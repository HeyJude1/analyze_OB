// Driver for 01_blas_gemv for Serial, OpenMP, MPI, and MPI+OpenMP
// Matrix-Vector Multiplication: y = alpha * A * x + beta * y
// Based on OpenBLAS dgemv_n implementation

#include <algorithm>
#include <cmath>
#include <numeric>
#include <random>
#include <vector>

#include "utilities.hpp"
#include "baseline.hpp"
#include "generated-code.hpp"   // code generated by LLM

struct Context {
    std::vector<double> A;
    std::vector<double> x;
    std::vector<double> y;
    std::vector<double> y_ref;  // reference result
    BLASLONG m, n;
    BLASLONG lda;
    BLASLONG inc_x, inc_y;
    double alpha, beta;
};

void reset(Context *ctx) {
    // Fill matrix and vectors with random values
    fillRand(ctx->A, -1.0, 1.0);
    fillRand(ctx->x, -1.0, 1.0);
    fillRand(ctx->y, -1.0, 1.0);
    
    // Broadcast for MPI consistency
    BCAST(ctx->A, DOUBLE);
    BCAST(ctx->x, DOUBLE);
    BCAST(ctx->y, DOUBLE);
    
    // Copy y for reference computation
    ctx->y_ref = ctx->y;
}

Context *init() {
    Context *ctx = new Context();
    
    // Problem size
    ctx->m = DRIVER_PROBLEM_SIZE;
    ctx->n = DRIVER_PROBLEM_SIZE;
    
    // Leading dimension (row-major)
    ctx->lda = ctx->n;
    
    // Stride parameters (unit stride for simplicity)
    ctx->inc_x = 1;
    ctx->inc_y = 1;
    
    // BLAS parameters
    ctx->alpha = 1.0;
    ctx->beta = 0.0;  // y = A * x (no accumulation)
    
    // Allocate memory
    ctx->A.resize(ctx->m * ctx->n);
    ctx->x.resize(ctx->n);
    ctx->y.resize(ctx->m);
    ctx->y_ref.resize(ctx->m);
    
    reset(ctx);
    return ctx;
}

void NO_OPTIMIZE compute(Context *ctx) {
    // Call the LLM-generated function
    // Expected signature: gemv(m, n, alpha, A, lda, x, inc_x, beta, y, inc_y)
    gemv(ctx->m, ctx->n, ctx->alpha,
         ctx->A, ctx->lda, ctx->x, ctx->inc_x,
         ctx->beta, ctx->y, ctx->inc_y);
}

void NO_OPTIMIZE best(Context *ctx) {
    // Call the reference implementation
    correctGemv(ctx->m, ctx->n, ctx->alpha,
                ctx->A, ctx->lda, ctx->x, ctx->inc_x,
                ctx->beta, ctx->y_ref, ctx->inc_y);
}

bool validate(Context *ctx) {
    const double tolerance = 1e-6;
    
    // Compute reference result
    std::vector<double> y_test = ctx->y;
    correctGemv(ctx->m, ctx->n, ctx->alpha,
                ctx->A, ctx->lda, ctx->x, ctx->inc_x,
                ctx->beta, y_test, ctx->inc_y);
    
    // Compare with generated result
    bool isValid = blas_utils::compareVectors(ctx->y, y_test, tolerance);
    
    if (!isValid) {
        double error = blas_utils::relativeError(ctx->y, y_test);
        printf("GEMV validation failed: relative error = %e\n", error);
    }
    
    return isValid;
}

void destroy(Context *ctx) {
    delete ctx;
}
