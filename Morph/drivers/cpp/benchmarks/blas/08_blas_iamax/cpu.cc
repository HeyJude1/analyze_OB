// Driver for 08_blas_iamax for Serial, OpenMP, MPI, and MPI+OpenMP
// Index of Maximum Absolute Value: result = argmax(|x[i]|)
// Based on OpenBLAS idamax_k implementation

#include <algorithm>
#include <cmath>
#include <numeric>
#include <random>
#include <vector>

#include "utilities.hpp"
#include "baseline.hpp"
#include "generated-code.hpp"   // code generated by LLM

struct Context {
    std::vector<double> x;
    BLASLONG result;
    BLASLONG result_ref;
    BLASLONG n;
    BLASLONG inc_x, inc_y;
};

void reset(Context *ctx) {
    // Fill vector with random values, ensure some variation
    fillRand(ctx->x, -10.0, 10.0);
    
    // Broadcast for MPI consistency
    BCAST(ctx->x, DOUBLE);
    
    // Reset results
    ctx->result = 0;
    ctx->result_ref = 0;
}

Context *init() {
    Context *ctx = new Context();
    
    // Problem size
    ctx->n = DRIVER_PROBLEM_SIZE;
    
    // Stride parameters (unit stride for simplicity)
    ctx->inc_x = 1;
    ctx->inc_y = 1;
    
    // Allocate memory
    ctx->x.resize(ctx->n);
    
    reset(ctx);
    return ctx;
}

void NO_OPTIMIZE compute(Context *ctx) {
    // Call the LLM-generated function
    // Expected signature: BLASLONG iamax(n, x, inc_x)
    ctx->result = iamax(ctx->n, ctx->x, ctx->inc_x);
}

void NO_OPTIMIZE best(Context *ctx) {
    // Call the reference implementation
    ctx->result_ref = correctIamax(ctx->n, ctx->x, ctx->inc_x);
}

bool validate(Context *ctx) {
    BLASLONG reference = correctIamax(ctx->n, ctx->x, ctx->inc_x);
    bool isValid = (ctx->result == reference);
    
    if (!isValid) {
        printf("IAMAX validation failed: computed=%ld, reference=%ld\n", 
               ctx->result, reference);
        printf("  x[computed]=%e, x[reference]=%e\n", 
               ctx->x[ctx->result], ctx->x[reference]);
    }
    
    return isValid;
}

void destroy(Context *ctx) {
    delete ctx;
}
