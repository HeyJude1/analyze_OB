# OpenBLAS BLAS算子选择报告

## 执行总结

✅ **已成功选择10个BLAS算子的参考实现**

**来源**：`/home/dgc/mjs/project/analyze_OB/openblas-output/GENERIC/kernel`

**存放位置**：`/home/dgc/mjs/project/analyze_OB/openblas_reference_kernels/`

---

## 选定算子清单

| # | 算子 | 文件名 | 源文件 | 行数 | Level | 类型 | 评估结果 |
|---|------|--------|--------|------|-------|------|---------|
| 1 | GEMM | 01_gemm.c | dgemm_small_kernel_b0_nn.clean.c | 17 | 3 | 矩阵乘 | ✅ 适合 |
| 2 | GEMV | 02_gemv.c | dgemv_n.clean.c | 25 | 2 | 矩向乘 | ✅ 适合 |
| 3 | AXPBY | 03_axpby.c | daxpby_k.clean.c | 55 | 1 | 向量运算 | ✅ 适合 |
| 4 | DOT | 04_dot.c | ddot_k.clean.c | 16 | 1 | 归约 | ✅ 适合 |
| 5 | SWAP | 05_swap.c | dswap_k.clean.c | 18 | 1 | 内存操作 | ✅ 适合 |
| 6 | COPY | 06_copy.c | dcopy_k.clean.c | 15 | 1 | 内存操作 | ✅ 适合 |
| 7 | NRM2 | 07_nrm2.c | dnrm2_k.clean.c | 31 | 1 | 归约 | ✅ 适合 |
| 8 | ASUM | 08_asum.c | dasum_k.clean.c | 15 | 1 | 归约 | ✅ 适合 |
| 9 | IAMAX | 09_iamax.c | idamax_k.clean.c | 24 | 1 | 归约+索引 | ✅ 适合 |
| 10 | IAMIN | 10_iamin.c | idamin_k.clean.c | 24 | 1 | 归约+索引 | ✅ 适合 |

---

## 详细评估

### 1. GEMM（矩阵-矩阵乘法）✅

**源码分析**：
```c
int dgemm_small_kernel_b0_nn(BLASLONG M, BLASLONG N, BLASLONG K, 
                             double *A, BLASLONG lda, double alpha, 
                             double *B, BLASLONG ldb, 
                             double *C, BLASLONG ldc)
{
    // 标准的三重循环实现
    for(i=0; i<M; i++){
        for(j=0; j<N; j++){
            result=0.0;
            for(k=0; k<K; k++){
                result += A[i+k*lda] * B[k+j*ldb];
            }
            C[i+j*ldc]=alpha * result;
        }
    }
}
```

**适用性**：
- ✅ **简洁清晰**：17行代码，易于理解
- ✅ **标准实现**：i-j-k循环顺序，适合作为baseline
- ✅ **优化空间大**：可以应用分块、循环展开、SIMD等多种优化
- ✅ **易于测试**：输入输出明确，易于验证

**可测试性**：⭐⭐⭐⭐⭐
- 可以编写单元测试
- 易于生成随机测试用例
- 结果验证简单（矩阵比较）

---

### 2. GEMV（矩阵-向量乘法）✅

**源码分析**：
```c
int dgemv_n(BLASLONG m, BLASLONG n, BLASLONG dummy1, double alpha, 
            double *a, BLASLONG lda, double *x, BLASLONG inc_x, 
            double *y, BLASLONG inc_y, double *buffer)
{
    // 外层循环遍历矩阵的列
    for (j=0; j<n; j++) {
        temp = alpha * x[ix];
        // 内层循环更新y向量
        for (i=0; i<m; i++) {
            y[iy] += temp * a_ptr[i];
            iy += inc_y;
        }
        a_ptr += lda;
        ix += inc_x;
    }
}
```

**适用性**：
- ✅ **支持stride**：inc_x和inc_y参数，测试内存访问模式
- ✅ **指针操作**：使用a_ptr，体现指针算术优化
- ✅ **中等复杂度**：25行，适合测试LLM的理解能力

**可测试性**：⭐⭐⭐⭐⭐

---

### 3. AXPBY（向量缩放与加法）✅

**源码分析**：
```c
int daxpby_k(BLASLONG n, double alpha, double *x, BLASLONG inc_x, 
             double beta, double *y, BLASLONG inc_y)
{
    // 特殊情况优化
    if (beta == 0.0) {
        if (alpha == 0.0) {
            // y = 0
        } else {
            // y = alpha * x
        }
    } else {
        if (alpha == 0.0) {
            // y = beta * y
        } else {
            // y = alpha * x + beta * y (通用情况)
        }
    }
}
```

**适用性**：
- ✅ **分支优化典范**：4种特殊情况处理
- ✅ **测试分支预测**：LLM是否能学到分支优化
- ✅ **实用性强**：AXPBY是许多算法的核心操作

**可测试性**：⭐⭐⭐⭐⭐
- 需要测试4种分支情况
- 测试LLM对特殊情况的处理能力

---

### 4. DOT（向量点积）✅

**源码分析**：
```c
double ddot_k(BLASLONG n, double *x, BLASLONG inc_x, 
              double *y, BLASLONG inc_y)
{
    double dot = 0.0;
    while(i < n) {
        dot += y[iy] * x[ix];
        ix += inc_x;
        iy += inc_y;
        i++;
    }
    return(dot);
}
```

**适用性**：
- ✅ **最简归约**：16行，适合测试并行归约
- ✅ **数值精度**：测试浮点累加精度
- ✅ **并行化挑战**：OMP reduction、CUDA atomicAdd

**可测试性**：⭐⭐⭐⭐⭐

---

### 5. SWAP（向量交换）✅

**源码分析**：
```c
int dswap_k(... double *x, ... double *y, ...)
{
    while(i < n) {
        temp = x[ix];
        x[ix] = y[iy];
        y[iy] = temp;
        ix += inc_x;
        iy += inc_y;
        i++;
    }
}
```

**适用性**：
- ✅ **内存操作**：测试LLM对内存读写的理解
- ✅ **临时变量**：测试寄存器使用
- ✅ **并行化难点**：需要处理数据依赖

**可测试性**：⭐⭐⭐⭐⭐

---

### 6. COPY（向量复制）✅

**源码分析**：
```c
int dcopy_k(BLASLONG n, double *x, BLASLONG inc_x, 
            double *y, BLASLONG inc_y)
{
    while(i < n) {
        y[iy] = x[ix];
        ix += inc_x;
        iy += inc_y;
        i++;
    }
}
```

**适用性**：
- ✅ **最简单操作**：15行，测试baseline能力
- ✅ **内存带宽**：测试连续vs非连续访问
- ✅ **SIMD化容易**：测试LLM的向量化能力

**可测试性**：⭐⭐⭐⭐⭐

---

### 7. NRM2（向量2-范数）✅

**源码分析**：
```c
double dnrm2_k(BLASLONG n, double *x, BLASLONG inc_x)
{
    double scale = 0.0;
    double ssq = 1.0;
    // 使用scale和ssq算法避免溢出
    while(i < n) {
        if (x[i] != 0.0) {
            absxi = fabs(x[i]);
            if (scale < absxi) {
                ssq = 1 + ssq * (scale/absxi) * (scale/absxi);
                scale = absxi;
            } else {
                ssq += (absxi/scale) * (absxi/scale);
            }
        }
        i += inc_x;
    }
    return scale * sqrt(ssq);
}
```

**适用性**：
- ✅ **数值稳定性**：测试LLM对数值问题的理解
- ✅ **算法复杂度**：不是简单的平方和开方
- ✅ **分支逻辑**：条件判断较多

**可测试性**：⭐⭐⭐⭐
- 需要测试数值稳定性
- 需要测试大/小数值情况

---

### 8. ASUM（向量绝对值和）✅

**源码分析**：
```c
double dasum_k(BLASLONG n, double *x, BLASLONG inc_x)
{
    double sumf = 0.0;
    while(i < n) {
        sumf += fabs(x[i]);
        i += inc_x;
    }
    return(sumf);
}
```

**适用性**：
- ✅ **简单归约**：15行，易于理解
- ✅ **绝对值处理**：测试fabs的使用
- ✅ **并行化容易**：适合测试reduction

**可测试性**：⭐⭐⭐⭐⭐

---

### 9. IAMAX（最大绝对值索引）✅

**源码分析**：
```c
BLASLONG idamax_k(BLASLONG n, double *x, BLASLONG inc_x)
{
    BLASLONG max=0;
    double maxf=0.0;
    maxf=fabs(x[0]);
    while(i < n) {
        if(fabs(x[ix]) > maxf) {
            max = i;
            maxf = fabs(x[ix]);
        }
        ix += inc_x;
        i++;
    }
    return(max+1);  // BLAS使用1-based索引
}
```

**适用性**：
- ✅ **归约+索引**：测试复合操作
- ✅ **条件更新**：测试argmax模式
- ✅ **返回索引**：注意1-based vs 0-based

**可测试性**：⭐⭐⭐⭐⭐

---

### 10. IAMIN（最小绝对值索引）✅

**源码分析**：
- 与IAMAX完全对偶，只是比较符号从`>`变为`<`
- 测试LLM对对称算法的理解

**适用性**：
- ✅ **对偶操作**：与IAMAX配对测试
- ✅ **完整性**：补全min/max操作

**可测试性**：⭐⭐⭐⭐⭐

---

## 总体评估

### 优点总结

1. **代码质量**：
   - ✅ 所有代码都来自OpenBLAS官方GENERIC实现
   - ✅ 久经考验，正确性有保障
   - ✅ 代码简洁（15-55行），易于LLM学习

2. **覆盖全面**：
   - Level 1 BLAS：8个（DOT、AXPBY、SWAP、COPY、NRM2、ASUM、IAMAX、IAMIN）
   - Level 2 BLAS：1个（GEMV）
   - Level 3 BLAS：1个（GEMM）

3. **计算模式多样**：
   - 归约操作：DOT、NRM2、ASUM、IAMAX、IAMIN
   - 逐元素操作：AXPBY、COPY
   - In-place操作：SWAP
   - 矩阵运算：GEMV、GEMM

4. **优化空间大**：
   - 循环展开：所有算子
   - SIMD向量化：COPY、AXPBY、DOT、ASUM
   - 缓存分块：GEMM、GEMV
   - 并行归约：DOT、NRM2、ASUM、IAMAX、IAMIN
   - 分支优化：AXPBY、NRM2

5. **适合Morph测试**：
   - ✅ 函数签名明确
   - ✅ 易于编写测试驱动
   - ✅ 可以直接集成到Morph框架

### 可能的挑战

1. **类型定义**：
   - 需要定义 `BLASLONG` 类型（可以typedef为long或int64_t）
   - 示例：`typedef long BLASLONG;`

2. **预处理标记**：
   - 部分文件开头有 `# 行号 "路径"` 的预处理器标记
   - 可以保留（不影响编译）或删除（更清晰）

3. **缺少头文件**：
   - 需要添加 `#include <cmath>` （fabs、sqrt）
   - 需要添加 `#include <cstdint>` （BLASLONG定义）

---

## 编写测试代码的建议

### 每个算子需要的驱动文件

以 GEMM 为例，需要创建：

```
Morph/drivers/cpp/benchmarks/blas/
└── 00_blas_gemm/
    ├── baseline.hpp         # 正确的参考实现（直接使用01_gemm.c的代码）
    ├── cpu.cc              # Serial/OMP/MPI驱动
    ├── gpu.cu              # CUDA驱动
    └── kokkos.cc           # Kokkos驱动（可选）
```

### baseline.hpp 示例

```cpp
#pragma once
#include <cmath>

typedef long BLASLONG;

// 直接使用OpenBLAS的实现
int correctGemm(BLASLONG M, BLASLONG N, BLASLONG K, 
                double *A, BLASLONG lda, double alpha, 
                double *B, BLASLONG ldb, 
                double *C, BLASLONG ldc)
{
    BLASLONG i,j,k;
    double result=0.0;
    for(i=0; i<M; i++){
        for(j=0; j<N; j++){
            result=0.0;
            for(k=0; k<K; k++){
                result += A[i+k*lda] * B[k+j*ldb];
            }
            C[i+j*ldc]=alpha * result;
        }
    }
    return 0;
}
```

### 驱动代码要点

1. **Context结构**：
   - GEMM：需要矩阵A、B、C和维度M、N、K
   - GEMV：需要矩阵A、向量x、y和维度m、n
   - Level 1：通常只需要向量和标量

2. **测试数据生成**：
   - 使用 `fillRand(vec, min, max)` 生成随机数据
   - 确保MPI环境下数据一致性（BCAST）

3. **验证逻辑**：
   - 多次随机测试（5-10次）
   - 允许浮点误差（1e-3 到 1e-6）
   - 特殊情况测试（边界条件、零矩阵等）

---

## 下一步行动

### 立即可做（优先级高）

1. **清理预处理标记**（可选）：
```bash
cd openblas_reference_kernels
for file in *.c; do
    # 删除第一行的预处理标记
    tail -n +2 "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"
done
```

2. **添加必要的头文件**：
创建 `common.h`：
```c
#ifndef BLAS_COMMON_H
#define BLAS_COMMON_H

#include <cmath>
#include <cstdint>

typedef int64_t BLASLONG;

#endif
```

3. **创建函数签名摘要**：
为后续生成prompt准备，提取每个函数的签名和注释。

### 后续步骤（按整合方案）

1. **创建 Morph baseline**（需要3-5天）：
   - 为每个算子编写 baseline.hpp
   - 编写 cpu.cc 驱动
   - 编写 gpu.cu 驱动（可选）

2. **运行 Operator_op2**（需要1天）：
   - 为每个算子提取优化策略
   - 生成10个 opinfo2.json 文件

3. **生成 Morph prompts**（需要0.5天）：
   - 创建 blas_prompt_generator.py
   - 整合优化策略到prompt

4. **代码生成与测试**（需要1天）：
   - 运行 CodeGenv4
   - 运行 run-all.py
   - 分析结果

---

## 结论

✅ **阶段一完成**：成功选择了10个高质量的BLAS算子参考实现

**选择的算子**：
- ✅ 代码简洁（15-55行）
- ✅ 逻辑清晰（易于LLM理解）
- ✅ 优化空间大（适合测试策略指导）
- ✅ 覆盖全面（Level 1/2/3 BLAS）
- ✅ 易于测试（函数签名明确）

**这10个算子非常适合**：
1. 作为Morph测试框架的baseline
2. 用于评估LLM的代码生成能力
3. 验证OpenBLAS优化策略的迁移性
4. 研究知识驱动的代码生成效果

**建议下一步**：
- 优先实现3个核心算子（GEMM、GEMV、AXPBY）
- 验证完整流程
- 再扩展到全部10个算子
